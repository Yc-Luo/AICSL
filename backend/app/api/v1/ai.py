"""AI conversation and intervention API routes."""

from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from fastapi.responses import StreamingResponse
from sse_starlette.sse import EventSourceResponse

from app.api.v1.auth import get_current_user
from app.core.permissions import check_project_permission
from app.repositories.ai_conversation import AIConversation
from app.repositories.ai_intervention_rule import AIInterventionRule
from app.repositories.ai_role import AIRole
from app.repositories.project import Project
from app.repositories.user import User
from app.core.schemas.ai import (
    AIChatRequest,
    AIChatResponse,
    AIContextActionRequest,
    AIConversationListResponse,
    AIConversationResponse,
    AIMessageListResponse,
    AIMessageResponse,
    AIRoleListResponse,
    AIRoleResponse,
    InterventionRuleCreateRequest,
    InterventionRuleResponse,
    InterventionRuleUpdateRequest,
)
from app.repositories.ai_message import AIMessage
from app.services.ai_service import ai_service
from app.services.intervention_service import intervention_service
from app.services.rag_service import rag_service
from app.services.agents.agent_service import agent_service

router = APIRouter(prefix="/ai", tags=["ai"])


@router.post("/chat", response_model=AIChatResponse)
async def chat(
    chat_data: AIChatRequest,
    current_user: User = Depends(get_current_user),
) -> AIChatResponse:
    """Non-streaming AI chat."""
    # Check project access
    project = await Project.get(chat_data.project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission
    if not check_project_permission(
        current_user, project.owner_id, current_user.role
    ):
        is_member = any(
            m.get("user_id") == str(current_user.id) for m in project.members
        )
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this project",
            )

    # Retrieve context using RAG if enabled
    context = None
    if chat_data.use_rag:
        try:
            context = await rag_service.retrieve_context(
                chat_data.project_id, chat_data.message
            )
        except Exception as e:
            print(f"RAG Error: {e}")
            context = None

    # Chat with AI
    response = await ai_service.chat(
        project_id=chat_data.project_id,
        user_id=str(current_user.id),
        message=chat_data.message,
        role_id=chat_data.role_id,
        conversation_id=chat_data.conversation_id,
        context=context,
    )

    return AIChatResponse(
        conversation_id=response["conversation_id"],
        message=response["message"],
        citations=response.get("citations", []),
        suggestions=response.get("suggestions", []),
    )


@router.post("/action", response_model=AIChatResponse)
async def ai_action(
    action_data: AIContextActionRequest,
    current_user: User = Depends(get_current_user),
) -> AIChatResponse:
    """Specialized AI context-aware actions."""
    # Check project access
    project = await Project.get(action_data.project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission
    if not check_project_permission(current_user, project.owner_id, current_user.role):
        is_member = any(m.get("user_id") == str(current_user.id) for m in project.members)
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this project",
            )

    # Define specialized prompts based on action type
    prompts = {
        "summarize": f"请对以下{action_data.context_type}的内容进行结构化总结。请使用 Markdown 标题、分点列表或表格形式，确保逻辑清晰、重点突出：\n\n",
        "knowledge_graph": f"请针对以下{action_data.context_type}的内容，提取核心概念并梳理其关联。请使用 Markdown 层级列表或 Mermaid 语法（graph TD）来展示知识图谱，并附带简要的概念说明：\n\n",
        "optimize": f"请分析以下{action_data.context_type}的内容并给出专业建议。请采用『现状分析』、『改进建议』、『预期效果』三个板块进行展示，使用 Markdown 格式确保可读性：\n\n",
        "devil_advocate": f"请作为“恶魔代言人 (Devil's Advocate)”，审视以下论证结构。请识别逻辑谬误、证据薄弱环节，并提出至少 3 个尖锐的反驳观点。请直接以 Markdown 列表形式输出建议：\n\n",
        "inquiry_clustering": f"请分析以下探究内容中的核心概念，并将其归类为 3-4 个逻辑模块。请使用 Markdown 形式展示每个模块的名称及其包含的要点，帮助我理清思路：\n\n",
    }
    
    system_prompt = (
        "你是一个极其专业的协作学习助理。你擅长将杂乱的信息转化为结构清晰、视觉友好的 Markdown 文档。\n"
        "回答原则：\n"
        "1. 严禁输出大段不换行的文字。\n"
        "2. 必须使用 Markdown 标题（# ## ###）来区分模块。\n"
        "3. 核心结论请使用加粗（**关键词**）。\n"
        "4. 合理使用引用块（>）或代码块来突出重点。\n"
        "5. 如果内容包含步骤或多个要点，请使用有序或无序列表。"
    )
    user_message = f"{prompts.get(action_data.action_type, '')}{action_data.content}"
    if action_data.additional_query:
        user_message += f"\n\n用户特别要求：{action_data.additional_query}"

    # Use ai_service to perform the chat
    # We pass use_rag=False because the context is already provided explicitly in the content
    response = await ai_service.chat(
        project_id=action_data.project_id,
        user_id=str(current_user.id),
        message=user_message,
        role_id=None, # Use default role
        conversation_id=None, # New session for each action usually
        system_message_override=system_prompt,
        category="action",
    )

    return AIChatResponse(
        conversation_id=response["conversation_id"],
        message=response["message"],
        suggestions=[],
    )


@router.post("/chat/stream")
async def chat_stream(
    chat_data: AIChatRequest,
    current_user: User = Depends(get_current_user),
):
    """Streaming AI chat (SSE)."""
    # Check project access
    project = await Project.get(chat_data.project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission
    if not check_project_permission(
        current_user, project.owner_id, current_user.role
    ):
        is_member = any(
            m.get("user_id") == str(current_user.id) for m in project.members
        )
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this project",
            )

    # Retrieve context using RAG if enabled
    context = None
    if chat_data.use_rag:
        try:
            context = await rag_service.retrieve_context(
                chat_data.project_id, chat_data.message
            )
        except Exception as e:
            print(f"RAG Error: {e}")
            context = None

    
    async def generate():
        # Unified Deep Agents Routing
        # We ignore the distinction between legacy roles and new personas.
        # The Supervisor (in AgentService) will handle intent and delegation.
        
        # Construct context string if RAG is enabled
        final_message = chat_data.message
        if context:
            final_message = f"Context:\n{context['content']}\n\nUser Question: {chat_data.message}"
        
        try:
            async for chunk in agent_service.chat_stream(
                persona_key=chat_data.role_id, # Passed but currently ignored by Supervisor logic
                message=final_message,
                session_id=str(chat_data.conversation_id or "temp"),
                subject="General", # Could be retrieved from Project domain
            ):
                yield chunk
        except Exception as e:
            # Fallback for debugging, yield nothing or error
            print(f"Agent Service Error: {e}")
            yield f"[System Error]: {str(e)}"

    return EventSourceResponse(generate())


@router.get("/conversations/{project_id}", response_model=AIConversationListResponse)
async def get_conversations(
    project_id: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    current_user: User = Depends(get_current_user),
) -> AIConversationListResponse:
    """Get AI conversations for a project."""
    # Check project access
    project = await Project.get(project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission
    if not check_project_permission(
        current_user, project.owner_id, current_user.role
    ):
        is_member = any(
            m.get("user_id") == str(current_user.id) for m in project.members
        )
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this project",
            )

    # Get conversations
    # Filter: Only show conversations that have at least one message
    # We use an aggregation pipeline to filter conversations by existence of messages
    pipeline = [
        {"$match": {"project_id": project_id, "category": "chat"}},
        {"$addFields": {"id_str": {"$toString": "$_id"}}},
        {
            "$lookup": {
                "from": "ai_messages",
                "localField": "id_str",
                "foreignField": "conversation_id",
                "as": "messages",
            }
        },
        {"$match": {"messages": {"$not": {"$size": 0}}}},
        {"$sort": {"updated_at": -1}},
        {"$skip": skip},
        {"$limit": limit},
    ]

    conversations_cursor = AIConversation.aggregate(pipeline)
    conversations = await conversations_cursor.to_list()

    # Calculate total for pagination (also filtering out empty ones)
    count_pipeline = [
        {"$match": {"project_id": project_id, "category": "chat"}},
        {"$addFields": {"id_str": {"$toString": "$_id"}}},
        {
            "$lookup": {
                "from": "ai_messages",
                "localField": "id_str",
                "foreignField": "conversation_id",
                "as": "messages",
            }
        },
        {"$match": {"messages": {"$not": {"$size": 0}}}},
        {"$count": "total"},
    ]
    count_result = await AIConversation.aggregate(count_pipeline).to_list()
    total = count_result[0]["total"] if count_result else 0

    return AIConversationListResponse(
        conversations=[
            AIConversationResponse(
                id=str(c["_id"]),
                project_id=c["project_id"],
                user_id=c["user_id"],
                role_id=c.get("persona_id") or "default",
                title=c.get("title", "新对话"),
                created_at=c["created_at"],
                updated_at=c["updated_at"],
            )
            for c in conversations
        ],
        total=total,
    )


@router.get("/conversations/{conversation_id}/messages", response_model=AIMessageListResponse)
async def get_messages(
    conversation_id: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    current_user: User = Depends(get_current_user),
) -> AIMessageListResponse:
    """Get messages for a conversation."""
    conversation = await AIConversation.get(conversation_id)
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found",
        )

    # Check permission (owner of conversation or member of project)
    if str(conversation.user_id) != str(current_user.id):
        project = await Project.get(conversation.project_id)
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found",
            )
        
        is_member = any(m.get("user_id") == str(current_user.id) for m in project.members)
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this conversation",
            )

    messages = (
        await AIMessage.find({"conversation_id": conversation_id})
        .skip(skip)
        .limit(limit)
        .sort("created_at")
        .to_list()
    )
    total = await AIMessage.find({"conversation_id": conversation_id}).count()

    return AIMessageListResponse(
        messages=[
            AIMessageResponse(
                id=str(m.id),
                conversation_id=m.conversation_id,
                role=m.role,
                content=m.content,
                citations=m.citations,
                created_at=m.created_at,
            )
            for m in messages
        ],
        total=total,
    )


@router.get("/roles", response_model=AIRoleListResponse)
async def get_ai_roles(
    current_user: User = Depends(get_current_user),
) -> AIRoleListResponse:
    """Get available AI roles."""
    roles = await AIRole.find().sort("is_default", -1).to_list()

    return AIRoleListResponse(
        roles=[
            AIRoleResponse(
                id=str(r.id),
                name=r.name,
                icon=r.icon,
                description=r.description,
                temperature=r.temperature,
                is_default=r.is_default,
                created_at=r.created_at,
            )
            for r in roles
        ]
    )


@router.post("/conversations", response_model=AIConversationResponse, status_code=status.HTTP_201_CREATED)
async def create_conversation(
    conversation_data: AIChatRequest,
    current_user: User = Depends(get_current_user),
) -> AIConversationResponse:
    """Initialize a new AI conversation."""
    # Check project access
    project = await Project.get(conversation_data.project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission
    if not check_project_permission(
        current_user, project.owner_id, current_user.role
    ):
        is_member = any(
            m.get("user_id") == str(current_user.id) for m in project.members
        )
        if not is_member and current_user.role not in ["admin", "teacher"]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to access this project",
            )
            
    # Check/Create conversation
    # If conversation_id is provided, verify it exists
    if conversation_data.conversation_id:
        conversation = await AIConversation.get(conversation_data.conversation_id)
        if conversation:
            return AIConversationResponse.from_orm(conversation)
            
    # Create new conversation
    # Resolve role alias to real ObjectId immediately
    persona_id = conversation_data.role_id or "default"
    role = await ai_service.get_role(persona_id)
    if not role:
        # Fallback to default if not found
        role = await ai_service.get_default_role()
    
    # Use the resolved real ID (or "default" only if DB is truly empty/broken, which schema might reject if it assumes ObjectId)
    # The AIConversation model defines persona_id as Optional[str]. We should store the real ID.
    final_persona_id = str(role.id) if role else "default"

    conversation = AIConversation(
        project_id=conversation_data.project_id,
        user_id=str(current_user.id),
        persona_id=final_persona_id,
    )
    await conversation.insert()

    return AIConversationResponse(
        id=str(conversation.id),
        project_id=conversation.project_id,
        user_id=conversation.user_id,
        role_id=final_persona_id,
        title=conversation.title,
        created_at=conversation.created_at,
        updated_at=conversation.updated_at,
    )


@router.delete("/conversations/{conversation_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_conversation(
    conversation_id: str,
    current_user: User = Depends(get_current_user),
) -> None:
    """Delete an AI conversation and its messages."""
    conversation = await AIConversation.get(conversation_id)
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found",
        )

    # Check permission
    if str(conversation.user_id) != str(current_user.id) and current_user.role not in ["admin", "teacher"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to delete this conversation",
        )

    # Delete associated messages
    await AIMessage.find({"conversation_id": conversation_id}).delete()
    
    # Delete conversation
    await conversation.delete()


@router.get("/intervention-rules/{project_id}", response_model=List[InterventionRuleResponse])
async def get_intervention_rules(
    project_id: str,
    current_user: User = Depends(get_current_user),
) -> List[InterventionRuleResponse]:
    """Get intervention rules for a project."""
    # Check project access
    project = await Project.get(project_id)
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found",
        )

    # Check permission (Owner/Admin/Teacher only)
    is_owner = str(current_user.id) == project.owner_id
    if not (is_owner or current_user.role in ["admin", "teacher"]):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only owner, admin, and teacher can view intervention rules",
        )

    # Get rules (project-specific and global)
    rules = (
        await AIInterventionRule.find(
            {
                "$or": [
                    {"project_id": project_id},
                    {"project_id": None},  # Global rules
                ]
            }
        )
        .sort("-priority")
        .to_list()
    )

    return [
        InterventionRuleResponse(
            id=str(r.id),
            project_id=r.project_id,
            rule_type=r.rule_type,
            name=r.name,
            description=r.description,
            priority=r.priority,
            enabled=r.enabled,
            silence_threshold=r.silence_threshold,
            emotion_keywords=r.emotion_keywords,
            trigger_keywords=r.trigger_keywords,
            action_type=r.action_type,
            message_template=r.message_template,
            ai_role_id=r.ai_role_id,
            created_at=r.created_at,
            updated_at=r.updated_at,
        )
        for r in rules
    ]


@router.post("/intervention-rules", response_model=InterventionRuleResponse, status_code=status.HTTP_201_CREATED)
async def create_intervention_rule(
    rule_data: InterventionRuleCreateRequest,
    current_user: User = Depends(get_current_user),
) -> InterventionRuleResponse:
    """Create an intervention rule."""
    # Check project access if project_id is provided
    if rule_data.project_id:
        project = await Project.get(rule_data.project_id)
        if not project:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Project not found",
            )

        # Only owner/admin/teacher can create project rules
        is_owner = str(current_user.id) == project.owner_id
        if not (is_owner or current_user.role in ["admin", "teacher"]):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only owner, admin, and teacher can create intervention rules",
            )
    else:
        # Only admin can create global rules
        if current_user.role != "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only admin can create global intervention rules",
            )

    # Create rule
    from datetime import datetime

    rule = AIInterventionRule(
        project_id=rule_data.project_id,
        rule_type=rule_data.rule_type,
        name=rule_data.name,
        description=rule_data.description,
        priority=rule_data.priority,
        enabled=rule_data.enabled,
        silence_threshold=rule_data.silence_threshold,
        emotion_keywords=rule_data.emotion_keywords,
        trigger_keywords=rule_data.trigger_keywords,
        action_type=rule_data.action_type,
        message_template=rule_data.message_template,
        ai_role_id=rule_data.ai_role_id,
    )
    await rule.insert()

    return InterventionRuleResponse(
        id=str(rule.id),
        project_id=rule.project_id,
        rule_type=rule.rule_type,
        name=rule.name,
        description=rule.description,
        priority=rule.priority,
        enabled=rule.enabled,
        silence_threshold=rule.silence_threshold,
        emotion_keywords=rule.emotion_keywords,
        trigger_keywords=rule.trigger_keywords,
        action_type=rule.action_type,
        message_template=rule.message_template,
        ai_role_id=rule.ai_role_id,
        created_at=rule.created_at,
        updated_at=rule.updated_at,
    )


@router.put("/intervention-rules/{rule_id}", response_model=InterventionRuleResponse)
async def update_intervention_rule(
    rule_id: str,
    rule_data: InterventionRuleUpdateRequest,
    current_user: User = Depends(get_current_user),
) -> InterventionRuleResponse:
    """Update an intervention rule."""
    rule = await AIInterventionRule.get(rule_id)
    if not rule:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Intervention rule not found",
        )

    # Check permission
    if rule.project_id:
        project = await Project.get(rule.project_id)
        if project:
            is_owner = str(current_user.id) == project.owner_id
            if not (is_owner or current_user.role in ["admin", "teacher"]):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to update this rule",
                )
    else:
        if current_user.role != "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only admin can update global rules",
            )

    # Update rule
    from datetime import datetime

    if rule_data.name:
        rule.name = rule_data.name
    if rule_data.description is not None:
        rule.description = rule_data.description
    if rule_data.priority is not None:
        rule.priority = rule_data.priority
    if rule_data.enabled is not None:
        rule.enabled = rule_data.enabled
    if rule_data.silence_threshold is not None:
        rule.silence_threshold = rule_data.silence_threshold
    if rule_data.emotion_keywords is not None:
        rule.emotion_keywords = rule_data.emotion_keywords
    if rule_data.trigger_keywords is not None:
        rule.trigger_keywords = rule_data.trigger_keywords
    if rule_data.action_type:
        rule.action_type = rule_data.action_type
    if rule_data.message_template:
        rule.message_template = rule_data.message_template
    if rule_data.ai_role_id is not None:
        rule.ai_role_id = rule_data.ai_role_id

    rule.updated_at = datetime.utcnow()
    await rule.save()

    return InterventionRuleResponse(
        id=str(rule.id),
        project_id=rule.project_id,
        rule_type=rule.rule_type,
        name=rule.name,
        description=rule.description,
        priority=rule.priority,
        enabled=rule.enabled,
        silence_threshold=rule.silence_threshold,
        emotion_keywords=rule.emotion_keywords,
        trigger_keywords=rule.trigger_keywords,
        action_type=rule.action_type,
        message_template=rule.message_template,
        ai_role_id=rule.ai_role_id,
        created_at=rule.created_at,
        updated_at=rule.updated_at,
    )


@router.delete("/intervention-rules/{rule_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_intervention_rule(
    rule_id: str,
    current_user: User = Depends(get_current_user),
) -> None:
    """Delete an intervention rule."""
    rule = await AIInterventionRule.get(rule_id)
    if not rule:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Intervention rule not found",
        )

    # Check permission
    if rule.project_id:
        project = await Project.get(rule.project_id)
        if project:
            is_owner = str(current_user.id) == project.owner_id
            if not (is_owner or current_user.role in ["admin", "teacher"]):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You don't have permission to delete this rule",
                )
    else:
        if current_user.role != "admin":
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only admin can delete global rules",
            )

    await rule.delete()

